--- boost/foreach.hpp	(revision 69637)
+++ boost/foreach.hpp	(working copy)
@@ -31,9 +31,11 @@
 
 // Some compilers let us detect even const-qualified rvalues at compile-time
 #if BOOST_WORKAROUND(BOOST_MSVC, >= 1310) && !defined(_PREFAST_)                                 \
- || (BOOST_WORKAROUND(__GNUC__, >= 4) && !defined(BOOST_INTEL) && !defined(BOOST_CLANG))         \
+ || (BOOST_WORKAROUND(__GNUC__, == 4) && (__GNUC_MINOR__ <= 5) && !defined(BOOST_INTEL) &&       \
+                                                                  !defined(BOOST_CLANG))         \
  || (BOOST_WORKAROUND(__GNUC__, == 3) && (__GNUC_MINOR__ >= 4) && !defined(BOOST_INTEL) &&       \
-                                                                  !defined(BOOST_CLANG))
+                                                                  !defined(BOOST_CLANG))         \
+ || !defined(BOOST_NO_RVALUE_REFERENCES)
 # define BOOST_FOREACH_COMPILE_TIME_CONST_RVALUE_DETECTION
 #else
 // Some compilers allow temporaries to be bound to non-const references.
@@ -80,6 +82,7 @@
 #include <boost/type_traits/is_const.hpp>
 #include <boost/type_traits/is_abstract.hpp>
 #include <boost/type_traits/is_base_and_derived.hpp>
+#include <boost/type_traits/is_rvalue_reference.hpp>
 #include <boost/iterator/iterator_traits.hpp>
 #include <boost/utility/addressof.hpp>
 #include <boost/foreach_fwd.hpp>
@@ -213,11 +216,16 @@
 template<typename Bool1>
 inline boost::mpl::not_<Bool1> *not_(Bool1 *) { return 0; }
 
+#ifdef BOOST_NO_RVALUE_REFERENCES
 template<typename T>
 inline boost::mpl::false_ *is_rvalue_(T &, int) { return 0; }
 
 template<typename T>
 inline boost::mpl::true_ *is_rvalue_(T const &, ...) { return 0; }
+#else
+template<typename T>
+inline boost::is_rvalue_reference<T&&> *is_rvalue_(T&& t, int) { return 0; }
+#endif
 
 template<typename T>
 inline boost::is_array<T> *is_array_(T const &) { return 0; }
